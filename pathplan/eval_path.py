'''
Dumps a Mavlink log file.
Input file should be a ".BIN" file in the format that qgroundcontrol uses,
which consists of a series of MAVLink packets, each with a 64 bit timestamp
header. The timestamp is in microseconds since 1970 (unix epoch).
'''
import sys, time, os, struct, json, fnmatch
from utils import load_shapefile, load_altfile
from shapely.geometry import LineString, Polygon
from shapely.strtree import STRtree
import matplotlib.pyplot as plt
import mpl_toolkits.mplot3d as Axes3D
from path_planner_numpy import read_tif

try:
    from pymavlink.mavextra import *
except:
    print("WARNING: Numpy missing, mathematical notation will not be supported..")

import inspect

from pymavlink import mavutil

# Input should be a .BIN file in the qgroundcontrol format
# Outputs an array of dictionaries each containing the packet data
def parse_dataflash_log(filename, planner=False, notimestamps=False,
        robust=True, dialect='ardupilotmega', zero_time_base=False,
        types=None, nottypes=None, csv_sep=',', format=None, follow=False,
        parms=False, nobaddata=True, show_source=True, showseq=True,
        source_system=None, source_component=None, link=None, condition=None):
    '''
    mlog = mavutil.mavlink_connection(filename, planner_format=planner,
                                      notimestamps=notimestamps,
                                      robust_parsing=robust,
                                      dialect=dialect,
                                      zero_time_base=zero_time_base)
    '''
    mlog = mavutil.mavlink_connection(filename)

    ext = os.path.splitext(filename)[1]
    isbin = ext in ['.bin', '.BIN']

    output = []
    # Keep track of data from the current timestep. If the following timestep has the same data, it's stored in here as well. Output should therefore have entirely unique timesteps.
    while True:
        m = mlog.recv_match(blocking=follow)
        if not m:
            # FIXME: Make sure to output the last CSV message before dropping out of this loop
            break

        mdict = m.to_dict()
        mdict['timestamp'] = m._timestamp
        output.append(mdict)

    return output

def evaluate_path(path, rtree, alts):
    intersected = []
    ls = LineString(path)
    tile = rtree.query(ls)
    for pot in tile:
        inter = pot.intersection(ls)
        if not inter.is_empty:
            alt = alts[inter.wkt]
            for x,y,z in inter.coords:
                if z <= alt:
                    intersected.append(inter)
                    break
    return intersected
          

def evaluate_path_with_buffer(path, rtree, alts, buffer):
    ls = LineString(path)
    inters = rtree.query(ls.buffer(buffer))

def plot_path(path, inters, surface):
    x, y, z = zip(*path)

    inter_xs = []
    inter_ys = []
    inter_zs = []
    for inter in inters:
        inter_x, inter_y, inter_z = zip(*inter.interior)
        inter_xs.extend(inter_x)
        inter_ys.extend(inter_y)
        inter_zs.extend(inter_z)

    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')

    surf_x, surf_y, surf_z = zip(*surface)
    
    ax.plot(x, y, z)
    ax.scatter(inter_xs, inter_ys, inter_zs)
    ax.plot_surface(surf_x, surf_y, surf_z)

    plt.show()
    



def load_path_from_bin(binfile_arr):
	

#TODO Come up with a good way to analyze the deviation between the generated and the flown path
if __name__ == '__main__':
    from argparse import ArgumentParser

    parser = ArgumentParser(description="Compares a bin file to both a generated path and the tif file")

    parser.add_argument("bin_file", metavar="BIN", type=str, help="Bin file generated by the simulator")
    parser.add_argument("path_file", metavar="PATH", type=str, help="Path json file ")
    parser.add_argument("buffer", metavar="BUFFER", type=str, help="Amount of distance we want between the copter and the surface at all times")
    parser.add_argument("geotiff", metavar="TIF", type=str, help="Tif file")
    parser.add_argument("--plot-gen", help="If set, plots the generated path along highliting its intersection with the surface", required=False)
    parser.add_argument("--plot-flown", help="If set, plots the flow path along with highlighting its intersection with the surface", required=False)

    args = parser.parse_args()

    #parsed_log = parse_dataflash_log(args.bin_file)

    path = json.load(open(args.path_file))
 
    #flown_path = load_path_from_bin(parsed_log) 

    shapes = load_shapefile(args.geotiff)

    tree = STRtree(shapes)

    alts = load_altfile(args.geotiff)

    orig_inter = eval_path(path, tree, alts)

    #flown_inter = eval_path(flown_path, tree, alts)

    surface = read_tif(args.geotiff)

    #This should hopefully be a list of tuples lol
    surface = zip(range(surface.shape[0]) * surface.shape[1], range(surface.shape[1]) * surface.shape[0], surface.reshape(surface.shape[0] * surface.shape[1], -1))

    if args.plot_gen:
        plot_path(path, orig_inter, surface)

    if args.plot_flown:
        plot_path(flown_path, flown_inter, surface)

    print("Generated path intersected {0} times with an intersection distance of {1}".format(len(orig_inter), reduce(lamba x,y: x + y.length, orig_inter, 0)))

    #print("Flown path intersected {0} times with an intersection distance of {1}".format(len(flown_inter), reduce(lamba x,y: x + y.length, flown_inter, 0)))
